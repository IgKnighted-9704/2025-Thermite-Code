package frc.robot.subsystems;

import com.revrobotics.AbsoluteEncoder;
import com.revrobotics.SparkMaxAbsoluteEncoder;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.SparkMax;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;

public class ClimbSubsystem extends SubsystemBase {

    // Main climb motor (CIM in brushed mode)
    private final SparkMax climbMotor = new SparkMax(
        Constants.ClimbConstants.CLIMB_MOTOR_A_ID, 
        MotorType.kBrushed
    );

    // Angle motor (also CIM, brushed) with absolute encoder
    private final SparkMax climbAngle = new SparkMax(
        Constants.ClimbConstants.CLIMB_MOTOR_B_ID, 
        MotorType.kBrushed
    );

    // Absolute encoder for the climb angle
    private final AbsoluteEncoder climbAngleEncoder = climbAngle.getAbsoluteEncoder(
        SparkMaxAbsoluteEncoder.Type.kDutyCycle
    );

    // PID for climb angle
    private final PIDController climbPID = new PIDController(
        Constants.ClimbConstants.CLIMB_kP,
        Constants.ClimbConstants.CLIMB_kI,
        Constants.ClimbConstants.CLIMB_kD
    );

    // Desired angle for the climb
    private double desiredAngle = 0.0;

    public ClimbSubsystem() {
        // Optional: set idle mode or current limits here
    }

    // Set an angle for the climb pivot
    public void setClimbAngle(double angle) {
        desiredAngle = angle;
    }

    // Manual override to move climb angle, ignoring PID
    public void changeClimbAngle(double speed) {
        double currPosition = climbAngleEncoder.getPosition();
        if (currPosition < Constants.ClimbConstants.CLIMB_MAX_POS 
                && currPosition > Constants.ClimbConstants.CLIMB_MIN_POS) {
            climbAngle.set(speed);
        } else {
            climbAngle.stopMotor();
        }
    }

    // Spin the main climb motor at a fixed speed
    public void climb() {
        climbMotor.set(0.35);
    }

    // Returns current climb angle
    public double getArmPos() {
        return climbAngleEncoder.getPosition();
    }

    @Override
    public void periodic() {
        // Run the PID if we're within valid angle limits
        if (desiredAngle > Constants.ClimbConstants.CLIMB_MIN_POS 
                && desiredAngle < Constants.ClimbConstants.CLIMB_MAX_POS) {
            double currentPos = climbAngleEncoder.getPosition();
            double power = climbPID.calculate(currentPos, desiredAngle);

            if (power > 1) {
                power = 1;
            } else if (power < -1) {
                power = -1;
            }
            climbAngle.set(power);
        } else {
            // If out of range, stop the angle motor
            climbAngle.stopMotor();
        }
    }
}
